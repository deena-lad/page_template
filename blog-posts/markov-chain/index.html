<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kirtan Gangani">
<meta name="dcterms.date" content="2025-07-10">

<title>Understanding Markov Chains – Homepage</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-bb05f5d0074da2129d766b238819cd35.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Homepage</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../blog-posts/index.html"> 
<span class="menu-text">Blogposts</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/Kirtan7311"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kirtan-gangani-k789/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction-what-is-a-markov-chain" id="toc-introduction-what-is-a-markov-chain" class="nav-link active" data-scroll-target="#introduction-what-is-a-markov-chain">Introduction: What is a Markov Chain?</a></li>
  <li><a href="#the-core-concepts-states-transitions-and-the-markov-property" id="toc-the-core-concepts-states-transitions-and-the-markov-property" class="nav-link" data-scroll-target="#the-core-concepts-states-transitions-and-the-markov-property">The Core Concepts: States, Transitions, and The Markov Property</a>
  <ul class="collapse">
  <li><a href="#states" id="toc-states" class="nav-link" data-scroll-target="#states">States</a></li>
  <li><a href="#transitions-and-probabilities" id="toc-transitions-and-probabilities" class="nav-link" data-scroll-target="#transitions-and-probabilities">Transitions and Probabilities</a></li>
  <li><a href="#the-markov-property" id="toc-the-markov-property" class="nav-link" data-scroll-target="#the-markov-property">The Markov Property</a></li>
  </ul></li>
  <li><a href="#initial-state-probability-prior-probability" id="toc-initial-state-probability-prior-probability" class="nav-link" data-scroll-target="#initial-state-probability-prior-probability">Initial State Probability / Prior Probability</a></li>
  <li><a href="#the-transition-matrix-a-numerical-map" id="toc-the-transition-matrix-a-numerical-map" class="nav-link" data-scroll-target="#the-transition-matrix-a-numerical-map">The Transition Matrix: A Numerical Map</a></li>
  <li><a href="#visualizing-the-state-diagram" id="toc-visualizing-the-state-diagram" class="nav-link" data-scroll-target="#visualizing-the-state-diagram">Visualizing The State Diagram</a></li>
  <li><a href="#types-of-markov-chains" id="toc-types-of-markov-chains" class="nav-link" data-scroll-target="#types-of-markov-chains">Types of Markov Chains</a>
  <ul class="collapse">
  <li><a href="#discrete-time-vs.-continuous-time" id="toc-discrete-time-vs.-continuous-time" class="nav-link" data-scroll-target="#discrete-time-vs.-continuous-time">Discrete-Time vs.&nbsp;Continuous-Time</a></li>
  <li><a href="#discrete-state-vs.-continuous-state" id="toc-discrete-state-vs.-continuous-state" class="nav-link" data-scroll-target="#discrete-state-vs.-continuous-state">Discrete-State vs.&nbsp;Continuous-State</a></li>
  </ul></li>
  <li><a href="#state-sampling-markov-chain-simulation" id="toc-state-sampling-markov-chain-simulation" class="nav-link" data-scroll-target="#state-sampling-markov-chain-simulation">State Sampling / Markov Chain Simulation</a>
  <ul class="collapse">
  <li><a href="#why-is-state-sampling-important" id="toc-why-is-state-sampling-important" class="nav-link" data-scroll-target="#why-is-state-sampling-important">Why is State Sampling Important?</a></li>
  <li><a href="#how-it-works-conceptually" id="toc-how-it-works-conceptually" class="nav-link" data-scroll-target="#how-it-works-conceptually">How it Works (Conceptually)</a></li>
  </ul></li>
  <li><a href="#real-world-applications" id="toc-real-world-applications" class="nav-link" data-scroll-target="#real-world-applications">Real-World Applications</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Understanding Markov Chains</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Probability</div>
    <div class="quarto-category">Statistics</div>
  </div>
  </div>



<div class="quarto-title-meta column-page-left">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Kirtan Gangani </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 10, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction-what-is-a-markov-chain" class="level1">
<h1>Introduction: What is a Markov Chain?</h1>
<p>Markov chains, named after Andrey Markov is a powerful mathematical model used to show a sequence of events where the probability of each event depends <em>only</em> on the state achieved in the previous event. It doesn’t care about the entire history that led to the current state, just the current state itself. This unique “memoryless” property makes them surprisingly versatile and useful for modeling a wide range of real-world phenomena.</p>
</section>
<section id="the-core-concepts-states-transitions-and-the-markov-property" class="level1">
<h1>The Core Concepts: States, Transitions, and The Markov Property</h1>
<p>To understand Markov Chains, we need to understand some concepts:</p>
<section id="states" class="level2">
<h2 class="anchored" data-anchor-id="states">States</h2>
<p><strong>States</strong> are all the possible “situations” or “conditions” our system can be in. For example:</p>
<ul>
<li><strong>Weather:</strong> Sunny, Cloudy, Rainy<br>
</li>
<li><strong>A Stock Price:</strong> Up, Down, Stagnant<br>
</li>
<li><strong>Your Mood:</strong> Happy, Neutral, Sad</li>
</ul>
</section>
<section id="transitions-and-probabilities" class="level2">
<h2 class="anchored" data-anchor-id="transitions-and-probabilities">Transitions and Probabilities</h2>
<p>A <strong>transition</strong> is simply the movement from one state to another. For example, the weather changing from “Sunny” to “Cloudy.”</p>
<p>Each transition comes with a <strong>transition probability</strong>, which is the likelihood of moving from a current state to a next state. These probabilities are always between 0 and 1.</p>
<p><strong>Note</strong>: For any given state in a system, the sum of the probabilities of all possible transitions originating from that state (including the probability of transitioning back to itself) must always equal 1. This holds true regardless of the total number of states in the system.</p>
</section>
<section id="the-markov-property" class="level2">
<h2 class="anchored" data-anchor-id="the-markov-property">The Markov Property</h2>
<p>The <strong>Markov Property</strong> means that the probability of moving to a future state depends only on the <strong>current state</strong>, and not on any of the states that came before it.</p>
<p>Imagine you’re playing Monopoly and you land on a specific square, it doesn’t matter if you got there by rolling 6 and 2, or by rolling 5 and 3. All that matters is that you are currently on that square. This “forgetfulness” of past events is what makes Markov Chains unique and, surprisingly, easier to model.</p>
</section>
</section>
<section id="initial-state-probability-prior-probability" class="level1">
<h1>Initial State Probability / Prior Probability</h1>
<p><strong>Initial state probability distribution</strong> gives information about where our system begins, sometimes also referred to as the <strong>prior probability</strong> or <strong>starting probability vector</strong>.</p>
<p>This vector represents the likelihood of the system being in each of its possible states at the very beginning (at time <span class="math inline">\(t=0\)</span>).</p>
<p>Let’s denote the initial state probability vector as <span class="math inline">\(\pi_0\)</span>. If we have <span class="math inline">\(N\)</span> states, then <span class="math inline">\(\pi_0\)</span> would be a row vector:</p>
<p><span class="math display">\[\pi_0 = \begin{pmatrix} P(\text{State}_1 \text{ at } t=0) &amp; P(\text{State}_2 \text{ at } t=0) &amp; \dots &amp; P(\text{State}_N \text{ at } t=0) \end{pmatrix}\]</span></p>
<p>Where <span class="math inline">\(P(\text{State}_i \text{ at } t=0)\)</span> is the probability of being in State <span class="math inline">\(i\)</span> at the initial time.</p>
<p><strong>Key characteristics of the initial state probability vector:</strong></p>
<ul>
<li><strong>Non-negative:</strong> Each probability must be greater than or equal to 0.</li>
<li><strong>Sums to 1:</strong> The sum of all probabilities in the vector must equal 1, as the system <em>must</em> be in one of the states at the start.</li>
</ul>
<p><strong>Example using our weather states:</strong></p>
<p>Suppose we want to start our weather prediction. We might have prior knowledge about today’s weather:</p>
<ul>
<li>There’s a 70% chance it’s Sunny.</li>
<li>There’s a 20% chance it’s Cloudy.</li>
<li>There’s a 10% chance it’s Rainy.</li>
</ul>
<p>In this case, our initial state probability vector <span class="math inline">\(\pi_0\)</span> would be:</p>
<p><span class="math display">\[\pi_0 = \begin{pmatrix} 0.7 &amp; 0.2 &amp; 0.1 \end{pmatrix}\]</span></p>
<p>If we are absolutely certain about the starting state (e.g., we know for a fact it’s Sunny today), then the initial state vector would have a 1 in the position corresponding to that state and 0s elsewhere:</p>
<p><span class="math display">\[\text{If starting state is definitively Sunny:} \quad \pi_0 = \begin{pmatrix} 1 &amp; 0 &amp; 0 \end{pmatrix}\]</span></p>
<p>This initial distribution is the first piece of information, along with the transition matrix, that allows us to forecast the probabilities of being in various states at future time steps.</p>
</section>
<section id="the-transition-matrix-a-numerical-map" class="level1">
<h1>The Transition Matrix: A Numerical Map</h1>
<p>While state diagrams are great for visualization, mathematically, we represent all these transition probabilities in a <strong>transition matrix</strong> (often denoted as <span class="math inline">\(P\)</span>).</p>
<p>This matrix is essentially a table where:</p>
<ul>
<li>Each <strong>row</strong> represents the <strong>current state</strong> (where you’re coming <em>from</em>).<br>
</li>
<li>Each <strong>column</strong> represents the <strong>next state</strong> (where you’re going <em>to</em>).<br>
</li>
<li>The value at the intersection of a row and a column is the probability of transitioning from the row’s state to the column’s state.</li>
</ul>
<p>Using our weather example, the transition matrix would look like this:</p>
<p><span class="math display">\[
P = \begin{pmatrix}
0.6 &amp; 0.3 &amp; 0.1 \\
0.2 &amp; 0.3 &amp; 0.5 \\
0.4 &amp; 0.1 &amp; 0.5
\end{pmatrix}
\]</span></p>
<p>Let’s represent this in Python using NumPy and Pandas for clear display:</p>
<div id="e79826a3" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>states <span class="op">=</span> [<span class="st">"Sunny"</span>, <span class="st">"Cloudy"</span>, <span class="st">"Rainy"</span>]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> np.array([</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Sunny Cloudy   Rainy</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0.6</span>,   <span class="fl">0.3</span>,   <span class="fl">0.1</span>], <span class="co"># Sunny </span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0.2</span>,   <span class="fl">0.3</span>,   <span class="fl">0.5</span>], <span class="co"># Cloudy </span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0.4</span>,   <span class="fl">0.1</span>,   <span class="fl">0.5</span>]  <span class="co"># Rainy</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>transition_df <span class="op">=</span> pd.DataFrame(P, index<span class="op">=</span>[<span class="ss">f"From </span><span class="sc">{</span>s<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> s <span class="kw">in</span> states], columns<span class="op">=</span>[<span class="ss">f"To </span><span class="sc">{</span>s<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> s <span class="kw">in</span> states])</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Our Weather Transition Matrix (P):"</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(transition_df)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Row sums should be equal to 1.0."</span>)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(transition_df.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Our Weather Transition Matrix (P):
             To Sunny  To Cloudy  To Rainy
From Sunny        0.6        0.3       0.1
From Cloudy       0.2        0.3       0.5
From Rainy        0.4        0.1       0.5

Row sums should be equal to 1.0.
From Sunny     1.0
From Cloudy    1.0
From Rainy     1.0
dtype: float64</code></pre>
</div>
</div>
</section>
<section id="visualizing-the-state-diagram" class="level1">
<h1>Visualizing The State Diagram</h1>
<p>A great way to understand the flow within a Markov Chain is through a <strong>state diagram</strong>. This visual representation uses circles for states and arrows for transitions, with the transition probabilities labeled on the arrows.</p>
<p>Let’s use a simple weather example:</p>
<ul>
<li>If it’s Sunny today, there’s a 60% chance it stays Sunny tomorrow, 30% chance it becomes Cloudy, and 10% chance it becomes Rainy.</li>
<li>If it’s Cloudy today, there’s a 20% chance it becomes Sunny, 30% chance it stays Cloudy, and 50% chance it becomes Rainy.</li>
<li>If it’s Rainy today, there’s a 40% chance it becomes Sunny, 10% chance it becomes Cloudy, and 50% chance it stays Rainy.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="state-diagram.jpg" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>State diagram. Source: <a href="https://en.proft.me/2014/04/14/how-simulate-markov-chain-r/">https://en.proft.me/2014/04/14/how-simulate-markov-chain-r/</a></p>
</section>
<section id="types-of-markov-chains" class="level1">
<h1>Types of Markov Chains</h1>
<p>While the core concepts remain the same, Markov Chains can be categorized in a couple of important ways, primarily based on how time and states are handled.</p>
<section id="discrete-time-vs.-continuous-time" class="level2">
<h2 class="anchored" data-anchor-id="discrete-time-vs.-continuous-time">Discrete-Time vs.&nbsp;Continuous-Time</h2>
<ul>
<li><p><strong>Discrete-Time Markov Chains (DTMC):</strong> In a DTMC, transitions between states occur at fixed, regular intervals or “steps.” Think of it like taking a snapshot of the system every hour, day, or year. Our weather example is a perfect DTMC because we’re looking at the weather “tomorrow” based on “today.” The transition matrix you’ve seen applies directly to DTMCs.</p></li>
<li><p><strong>Continuous-Time Markov Chains (CTMC):</strong> In contrast, CTMCs allow transitions to occur at <em>any</em> point in time, not just at predefined intervals. The amount of time spent in a particular state before transitioning is a random variable, often modeled by an exponential distribution. While more complex mathematically, CTMCs are used to model systems where events happen asynchronously, like customer arrivals in a queue or radioactive decay.</p></li>
</ul>
</section>
<section id="discrete-state-vs.-continuous-state" class="level2">
<h2 class="anchored" data-anchor-id="discrete-state-vs.-continuous-state">Discrete-State vs.&nbsp;Continuous-State</h2>
<p>This distinction refers to the nature of the states themselves.</p>
<ul>
<li><p><strong>Discrete-State Markov Chains:</strong> This is what we’ve been discussing. The system can only be in a finite (or countably infinite) number of distinct, separate states. Examples include: “Sunny,” “Cloudy,” “Rainy”; “Up,” “Down,” “Stagnant” for stock prices; or even the squares on a Monopoly board. All the examples and the transition matrix we’ve used so far fall into this category.</p></li>
<li><p><strong>Continuous-State Markov Chains:</strong> In these chains, the state space is continuous, meaning the system can take on any value within a range. For instance, modeling the exact temperature (e.g., 25.3 degrees, 25.31 degrees, etc.) or the precise stock price value over time. These are often more complex and are typically modeled using stochastic differential equations, moving beyond simple transition matrices. For an introductory understanding, focusing on discrete-state chains is appropriate.</p></li>
</ul>
</section>
</section>
<section id="state-sampling-markov-chain-simulation" class="level1">
<h1>State Sampling / Markov Chain Simulation</h1>
<p>While the transition matrix helps us understand the probabilities of moving between states, what if we want to see an actual <em>sequence</em> of events unfold according to these probabilities? This is where <strong>state sampling</strong>, also known as <strong>Markov Chain simulation</strong>, comes in.</p>
<p>Imagine we want to predict the weather for the next 10 days based on our weather Markov Chain. We don’t want to just know the <em>probabilities</em> of it being sunny on day 10; we want to simulate a <em>possible sequence</em> of weather conditions.</p>
<section id="why-is-state-sampling-important" class="level3">
<h3 class="anchored" data-anchor-id="why-is-state-sampling-important">Why is State Sampling Important?</h3>
<ul>
<li><strong>Understanding Long-Term Behavior:</strong> By simulating the chain for many steps, we can get a sense of its long-term behavior, such as how often it visits certain states, or what the probability of being in a particular state is after a very long time (this is related to the stationary distribution).</li>
<li><strong>Approximating Complex Probabilities:</strong> For very complex systems or chains with many states, analytically calculating probabilities for many steps into the future can be computationally intractable. Simulation provides a practical way to approximate these probabilities.</li>
<li><strong>Foundation for Markov Chain Monte Carlo (MCMC):</strong> State sampling is the core idea behind <strong>(MCMC)</strong> methods. MCMC is a powerful class of algorithms used extensively in statistics, machine learning, and computational physics to sample from complex probability distributions, especially in Bayesian inference. Instead of directly calculating an intractable distribution, MCMC constructs a Markov chain whose stationary distribution is the target distribution, and then samples from that chain.</li>
</ul>
</section>
<section id="how-it-works-conceptually" class="level3">
<h3 class="anchored" data-anchor-id="how-it-works-conceptually">How it Works (Conceptually)</h3>
<p>Let’s use our weather example to illustrate the process:</p>
<ol type="1">
<li><strong>Start in an Initial State:</strong> We pick a starting state. Let’s say it’s “Sunny” today.</li>
<li><strong>Consult the Transition Probabilities:</strong> Look at the row in the transition matrix corresponding to the current state (“Sunny”). We see:
<ul>
<li>Sunny to Sunny: 60%</li>
<li>Sunny to Cloudy: 30%</li>
<li>Sunny to Rainy: 10%</li>
</ul></li>
<li><strong>Randomly Select the Next State:</strong> Based on these probabilities, we “roll the dice” (or use a random number generator) to decide the next state.
<ul>
<li>If our random number (between 0 and 1) is <code>0.0</code> to <code>0.6</code>, the next state is “Sunny.”</li>
<li>If it’s <code>0.6</code> to <code>0.9</code>, the next state is “Cloudy.”</li>
<li>If it’s <code>0.9</code> to <code>1.0</code>, the next state is “Rainy.”</li>
</ul></li>
<li><strong>Repeat:</strong> The newly chosen state becomes the “current state,” and we repeat steps 2 and 3 for as many steps as we desire.</li>
</ol>
<p>By repeating this process many times, we generate a <strong>sequence of states</strong> that represents a possible path the system could take. If we run many such simulations, we can estimate the likelihood of various outcomes or the average behavior of the system over time.</p>
<p>Let’s simulate a short sequence of weather for 5 days, starting with Sunny:</p>
<div id="92edf4bf" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulate_markov_chain(initial_state_idx, P, num_steps, states_names):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    current_state_idx <span class="op">=</span> initial_state_idx</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    path <span class="op">=</span> [states_names[current_state_idx]]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_steps):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        probabilities <span class="op">=</span> P[current_state_idx, :]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        next_state_idx <span class="op">=</span> np.random.choice(<span class="bu">len</span>(states_names), p<span class="op">=</span>probabilities)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        current_state_idx <span class="op">=</span> next_state_idx</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        path.append(states_names[current_state_idx])</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> path</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>num_simulation_days <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>initial_weather_state <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>simulated_path <span class="op">=</span> simulate_markov_chain(initial_weather_state, P, num_simulation_days, states)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Simulated weather path for </span><span class="sc">{</span>num_simulation_days<span class="sc">}</span><span class="ss"> days, starting Sunny:"</span>)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(simulated_path)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="co"># You can run this cell multiple times to see different simulated paths</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Simulated weather path for 5 days, starting Sunny:
['Sunny', 'Rainy', 'Sunny', 'Sunny', 'Cloudy', 'Rainy']</code></pre>
</div>
</div>
</section>
</section>
<section id="real-world-applications" class="level1">
<h1>Real-World Applications</h1>
<p>Markov Chains are applied in countless real-world scenarios:</p>
<ul>
<li><strong>Weather Forecasting:</strong> As seen in our example, predicting future weather patterns.</li>
<li><strong>Google PageRank:</strong> One of the original algorithms that powered Google’s search engine. Web pages were considered states, and links between them were transitions. Pages with a higher “probability” of being navigated to (in the long run) by a random surfer were deemed more important and ranked higher.</li>
<li><strong>Natural Language Processing (NLP):</strong> Used in tasks like predicting the next word in a sentence (think predictive text on your phone), speech recognition, and spam filtering.</li>
<li><strong>Finance:</strong> Modeling stock price movements, option pricing, and credit risk.</li>
<li><strong>Biology:</strong> Analyzing DNA sequences, modeling population dynamics, and disease spread.</li>
<li><strong>Games:</strong> Analyzing game theory strategies, or even simple games like “Snakes and Ladders” can be modeled as Markov Chains.</li>
<li><strong>Customer Behavior:</strong> Modeling customer journeys through a website or predicting subscription churn.</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>